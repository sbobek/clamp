# Cluster Analysis with Multidimensional Prototypes (CLAMP)
## About
CLAMP main goal is to explain differences between clustering, by using state-of-the-art XAI methods and rule-based representation of explanations.
It generates bounding boxes that define boundaries of clusters to be explain and exploit it to generate better explanations of the clusters.

![](./pix/bounding-box.png)

CLAMP can use following rule-based explainers (included in the code):
  * [LUX](https://github.com/sbobek/lux) -- Bringhs uncertinaty to the explainable model by building local uncertain decision tree based on informaiton from model predictions.
  * [Anchor](https://github.com/marcotcr/anchor) -- An anchor explanation is a rule that sufficiently “anchors” the prediction locally – such that changes to the rest of the feature values of the instance do not matter.

## Installation
First of all clonde the repository and its submodules, and enter it:

```
git clone https://github.com/sbobek/clamp.git
cd clamp
git submodule update --init --recursive
```
Some of the packages used in CLAMP are not available in conda, hence the following code should set up all of the requirements in virtual environment:

```
conda create --name clampenv python=3.8
conda activate clampenv
conda install pip
pip install -r requirements.txt
```

Additionally if you want to work with [JupyterLab](https://jupyter.org/) install it and run it, while being in active `clampenv` environment by:

```
pip install jupyterlab
jupyter lab
```

Open `usage_example.ipynb` in your JupyterLab and see how CLAMP works in practice.

## Usage example
For complete usage example navigate to `usage_example.ipynb`

### Iris dataset example
In this example we assume that the goal is clustering, thus we only used as features, not on class label while training the model.
However we will test if the explanations generated by the model are aligned with ground truth (the class of the iris).
Read dataset and drop the target at the end.
``` python
from sklearn import datasets
iris = datasets.load_iris()
features = ['sepal_length','sepal_width','petal_length','petal_width']
target = 'calss'

#create daatframe with columns names as strings (LUX accepts only DataFrames withj string columns names)
dataset = pd.DataFrame(iris.data,columns=features)
dataset[target] = iris.target

data = dataset.drop(target, axis = 1)
```

Create CLAMP obkect with bounding_box_selection set to `random` and `LUX` as explanation model:

```python
clamp = CLAMP(clusterng_algorithm = KMeans(n_clusters = 3),
                classification_model = xgb.XGBClassifier(),
                description_points_ratio=5,
                test_size = 0.1,
                metric = 'minkowski',
                thresh = 0.9,
                bounding_box_selection ='random',
                explainer_type = 'lux',
                approach = 'other')
# parameters to adjust there is also possibility to change clustering algorithm and classification model
# available bounding_box_selection parameter: centroids, outliers, tree_query, random
```

Fit the model:

```python
clamp.fit(data)
```

See the justifications that CLAMP generated for each of the clusters.
Function `rem_hmr_files()` removes HMR files that can be used along with [HeaRTDroid](heartdroid.re) inference engine in external applications if needed.
``` python
r = clamp.justify()
rem_hmr_files() # remove temp hmr files
r
```
You should see following explanations for each of the clusters:

```
IF sepal_length < 6.4 AND sepal_length < 6.3 AND petal_width >= 1.0 AND petal_width >= 1.3 THEN 0 # Precision(1) Coverage(0.99)
IF sepal_width >= 3.8 AND sepal_length >= 6.4 AND petal_width >= 1.0 AND petal_width >= 1.5 THEN 2 # Precision(1) Coverage(0.99)
IF petal_length < 1.9 AND petal_length < 1.7 AND petal_width < 1.0 AND petal_width >= 0.4 THEN 1 # Precision(1) Coverage(0.99)
IF petal_length < 1.9 AND petal_length >= 1.7 AND petal_width < 1.0 AND petal_width < 0.5 THEN 1 # Precision(1) Coverage(0.99)
IF petal_length < 1.9 AND petal_length >= 1.7 AND petal_width < 1.0 AND petal_width >= 0.5 THEN 1 # Precision(1) Coverage(0.99)
IF petal_length >= 1.9 AND petal_width < 1.0 AND petal_width < 0.4 THEN 1 # Precision(1) Coverage(0.99)
IF petal_length >= 1.9 AND petal_width < 1.0 AND petal_width >= 0.4 THEN 1 # Precision(1) Coverage(0.99)
IF sepal_length < 6.4 AND sepal_length < 6.3 AND petal_width >= 1.0 AND petal_width < 1.3 THEN 0 # Precision(1) Coverage(0.99)
IF sepal_length >= 6.4 AND petal_width >= 1.0 AND petal_width < 1.5 AND petal_width < 1.4 THEN 0 # Precision(1) Coverage(0.98)
IF sepal_width >= 3.3 AND sepal_length < 6.4 AND sepal_length >= 6.3 AND petal_width >= 1.0 THEN 0 # Precision(1) Coverage(0.98)
IF petal_length < 1.9 AND petal_length < 1.7 AND petal_width < 1.0 AND petal_width < 0.4 THEN 1 # Precision(1) Coverage(0.98)
IF sepal_width < 3.3 AND sepal_length < 6.4 AND sepal_length >= 6.3 AND petal_width >= 1.0 THEN 0 # Precision(1) Coverage(0.97)
IF sepal_width < 3.8 AND sepal_length >= 6.4 AND petal_width >= 1.0 AND petal_width >= 1.5 THEN 2 # Precision(1) Coverage(0.97)
IF sepal_length >= 6.4 AND petal_width >= 1.0 AND petal_width < 1.5 AND petal_width >= 1.4 THEN 0 # Precision(1) Coverage(0.94)
```


## Cite this work
TBA
